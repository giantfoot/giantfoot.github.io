# JAVA 查漏补缺


> Java  **包装**

int 是我们常说的整形数字，是 Java 的 8 个原始数据类型（Primitive Types，boolean、byte 、short、char、int、float、double、long）之一。Java 语言虽然号称一切都是对象，但原始数据类型是例外。

Integer 是 int 对应的包装类，它有一个 int 类型的字段存储数据，并且提供了基本操作，比如数学运算、int 和字符串之间转换等。

在 Java 5 中，引入了自动装箱和自动拆箱功能（boxing/unboxing），Java 可以根据上下文，自动进行转换，极大地简化了相关编程。

关于 **Integer 的值缓存**，这涉及 Java 5 中另一个改进。构建 Integer 对象的传统方式是直接调用构造器，直接 new 一个对象。但是根据实践，我们发现大部分数据操作都是集中在有限的、较小的数值范围，因而，在 Java 5 中新增了静态工厂方法 **valueOf**，在调用它的时候会利用一个缓存机制，带来了明显的性能改进。按照 Javadoc，这个值默认缓存是 **-128 到 127** 之间。

自动装箱实际上算是一种语法糖。

什么是语法糖？

可以简单理解为 Java 平台为我们自动进行了一些转换，保证不同的写法在运行时等价，**它们发生在编译阶段，也就是生成的字节码是一致的**。

javac 替我们**自动把装箱转换为 Integer.valueOf()，把拆箱替换为 Integer.intValue()** ，这似乎这也顺道回答了另一个问题，既然调用的是 Integer.valueOf，自然能够得到缓存的好处啊。

- Boolean，缓存了 true/false 对应实例，确切说，只会返回两个常量实例 Boolean.TRUE/FALSE。

- Short，同样是缓存了 -128 到 127 之间的数值。
- Byte，数值有限，所以全部都被缓存。
- Character，缓存范围’\u0000’ 到 ‘\u007F’。

>Java语言中，\u转义字符的意思是“\u后面的1-4位16进制数表示的Unicode码对应的汉字”，而Unicode 0000 代表的字符是 NUL，也就是空的意思，如果把这个内字符输出到控制台，应该显示为空格那样才容对啊。
这个Unicode表与程序设计语言是没有关系的，也不需要进行换算，它就是一张预先定义好的表。不管在怎样的系统中，它都是相同的.虽然它转换为字符串输出为空格，但是它与空格、空字符串、NULL和"null"都不同，所以无法找到能够描述它的符号

Unicode字符集

https://www.qqxiuzi.cn/zh/unicode-zifu.php?plane=0



> 原则上，建议避免无意中的装箱、拆箱行为，尤其是在性能敏感的场合，创建 10 万个 Java 对象和 10 万个整数的开销可不是一个数量级的，不管是内存使用还是处理速度，光是对象头的空间占用就已经是数量级的差距了。我们其实可以把这个观点扩展开，使用原始数据类型、数组甚至本地代码实现等，在性能极度敏感的场景往往具有比较大的优势，用其替换掉包装类、动态数组（如 ArrayList）等可以作为性能优化的备选项。一些追求极致性能的产品或者类库，会极力避免创建过多对象。当然，在大多数产品代码里，并没有必要这么做，还是以开发效率优先。



原始数据类型的变量，显然要使用并发相关手段，才能保证线程安全，这些我会在专栏后面的并发主题详细介绍。如果有线程安全的计算需要，建议考虑使用类似 AtomicInteger、AtomicLong 这样的线程安全类。

特别的是，部分比较宽的数据类型，比如 float、double，甚至不能保证更新操作的原子性，可能出现程序读取到只更新了一半数据位的数值！

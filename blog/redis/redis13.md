#### 事务

**redis单条命令是保证原子性的，但事务不保证原子性**

redis事务本质：一组命令的集合，放入队列

一次性，顺序性，排他性，但没有隔离级别的概念，不像是关系型数据库各种脏读，不可重复读等概念。

所有命令在事务中，并没有直接执行，只有发起执行命令的时候才会执行。

> 步骤：

- 开启事务

  multi命令开启事务

- 命令入队
  各种保存或者更改删除命令，set name test

- 执行事务
  exec

执行exec命令后，该组事务结束。

> 放弃事务

discard命令，队列内的命令全部不会执行

> 编译型异常

代码有问题，某条命令出错（缺少参数等redis约定的规则不满足），事务中的所有命令都不会被执行。类比：车买回来就是坏的，根本开不了，启动不了

> 运行异常

人为的逻辑错误，比如除0，或者字符串相加，当条命令出错，其他命令照样执行。类比：车买回来是正常的，某天路上爆胎坏了，但还是可以开


> 悲观锁

任何时候都会加锁

> 乐观锁

任何时候都不会加锁，更新数据之前会判断下，检查之前是否有人更改过。MySQL使用的事version，redis使用watch。

> redis监视

```
set money 100
watch money   #监视money
multi         #事务开启，若期间数据没发生变化，则执行成功
decrby  money 20 #以20为间隔减去money
exec

线程一
watch money
multi
decrby money 30
decr age 100
这时候先不执行exec命令，而是开启线程二
set money 100000
这时候再返回线程一执行exec，会直接报错，返回nil，类似于volatile关键字。
线程一的变量在事务执行过程中被其他线程更改，则会被线程一感知到，因而报错

```
watch相当于乐观锁，当前线程执行前，另外线程修改了值，会导致修改失败，因为更改前会检查现在的值和之前的值是否一样。

线程一若想继续执行，要执行unwatch取消监视，然后再执行watch重新监视，exec也会自动解锁，如果exec执行的时候报错，也可以不用unwatch直接执行watch。

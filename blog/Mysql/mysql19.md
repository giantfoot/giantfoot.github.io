# MYSQL核心技术总结


> Mysql  **join**

- 使用 join 语句，性能比强行拆成多个单表执行 SQL 语句的性能要好；
- 如果使用 join 语句的话，需要让小表做驱动表。
> 但是，你需要注意，这个结论的前提是“可以使用被驱动表的索引”。

若是被驱动表上没有索引，那流程如下

1. 把表 t1 的数据读入线程内存 join_buffer 中，由于我们这个语句中写的是 select *，因此是把整个表 t1 放入了内存；
2. 扫描表 t2，把表 t2 中的每一行取出来，跟 join_buffer 中的数据做对比，满足 join 条件的，作为结果集的一部分返回。
3. 若t1有100条数据，那t2就要全表扫描100*100=10000遍。

如果被驱动表用不到索引：

  > 假设小表的行数是 N，大表的行数是 M，那么在这个算法里：两个表都做一次全表扫描，所以总的扫描行数是 M+N；内存中的判断次数是 M*N。可以看到，调换这两个算式中的 M 和 N 没差别，因此这时候选择大表还是小表做驱动表，执行耗时是一样的。

**但如果让大表做驱动表，内存可能不够用，需要分段，所以还是应该让小表当驱动表**


能不能使用 join 语句？

**如果可以用上被驱动表上的索引，那就没问题。否则最好不要用。**

如果要使用 join，应该选择大表做驱动表还是选择小表做驱动表？

**总是应该使用小表做驱动表。**


在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，过滤完成之后，计算参与 join 的各个字段的总数据量，数据量小的那个表，就是“小表”，应该作为驱动表。

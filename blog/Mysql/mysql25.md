# MYSQL核心技术总结


> Mysql  **易错知识点总结**

- 在 MySQL 里，NULL 跟任何值执行等值判断和不等值判断的结果，都是 NULL。这里包括， select NULL = NULL 的结果，也是返回 NULL。

- 即使我们在 SQL 语句中写成 left join，执行过程还是有可能不是从左到右连接的。也就是说，使用 left join 时，左边的表不一定是驱动表。

- 如果需要 left join 的语义，就不能把被驱动表的字段放在 where 条件里面做等值判断或不等值判断，必须都写在 on 里面。

**distinct 和 group by 的性能：**
```

select a from t group by a order by null;
select distinct a from t;
```

没有了 count(*) 以后，也就是不再需要执行“计算总数”的逻辑时，第一条语句的逻辑就变成是：
1. 按照字段 a 做分组，相同的 a 的值只返回一行。而这就是 distinct 的语义，所以不需要执行聚合函数时，distinct 和 group by 这两条语句的语义和执行流程是相同的，因此执行性能也相同。这两条语句的执行流程是下面这样的。
2. 创建一个临时表，临时表有一个字段 a，并且在这个字段 a 上创建一个唯一索引；遍历表 t，依次取数据插入临时表中：如果发现唯一键冲突，就跳过；否则插入成功；遍历完成后，将临时表作为结果集返回给客户端。

**自增id用完怎么办？**

表定义的自增值达到上限后的逻辑是：再申请下一个 id 时，得到的值保持不变。

>我们还是应该在 InnoDB 表中主动创建自增主键。因为，表自增 id 到达上限后，再插入数据时报主键冲突错误，是更能被接受的。毕竟覆盖数据，就意味着数据丢失，影响的是数据可靠性；报主键冲突，是插入失败，影响的是可用性。而一般情况下，可靠性优先于可用性。

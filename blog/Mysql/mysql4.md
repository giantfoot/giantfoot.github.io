# MYSQL核心技术总结


> Mysql **索引概述上**

- Mysql InnoDB 引擎使用的是B+树结构，分为主键索引（聚簇索引）和普通索引,使用B+树主要是为了减少访问磁盘的次数。

- 主键索引：叶子节点存储的是整行数据（实际存储的是页 page，页里面是有序数组，数组里面存的是行，用二分法查找具体的行）。

- 普通索引：叶子节点存储的是主键，需要回表去主键查询具体的行。

- 一般要使用自增主键，而Key-Value比较适合业务字段做主键。


- B+ 树相关介绍

  [B+ 树特征](https://www.jianshu.com/p/71700a464e97)

  [B+ 树的操作详解](https://blog.csdn.net/Fmuma/article/details/80287924)

### B+树特征

- B+ 树是一种树数据结构，是一个n叉树，每个节点通常有多个孩子，一颗B+树包含根节点、内部节点和叶子节点。B+ 树通常用于数据库和操作系统的文件系统中。 B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。 B+ 树元素自底向上插入。

- 一个m阶的B树具有如下几个特征：

      1.根结点至少有两个子女。

      2.每个中间节点都至少包含ceil(m / 2)个孩子，最多有m个孩子。

      3.每一个叶子节点都包含k-1个元素，其中 m/2 <= k <= m。

      4.所有的叶子结点都位于同一层。

      5.每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。


- 在本例中每一个父节点都出现在子节点中，是子节点最大或者最小的元素。而下面的例子中存在如果父结点存储的为子节点最小值，那么便不需要存储第一个子节点的内容。【例如子节点5、8--->10、15--->16、17、18意味着我父节点存10与16即可。而同样的例子如果父节点存最大值，那么便需要存8、15、18 】

- 在这里，根节点中最大的元素是15，也就是整个树中最大的元素。以后无论插入多少元素要始终保持最大元素在根节点当中。

- 每个叶子节点都有一个指针，指向下一个数据，形成一个有序链表。


- 而只有叶子节点才会有data，其他都是索引。

- B+树与B树的区别
  有k个子结点的结点必然有k个关键码；
  非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。
  树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。
  B+树的查询操作
  在单元查询的时候，B+树会自定向下逐层查找，最终找到匹配的叶子节点。例如我们查找3 。


- 而B+树中间节点没有Data数据，所以同样大小的磁盘页可以容纳更多的节点元素。所以数据量相同的情况下，B+树比B树更加“矮胖“，因此使用的IO查询次数更少。由于B树的查找并不稳定（最好的情况是查询根节点，最坏查询叶子节点）。而B树每一次查找都是稳定的。

- 比起B树，B+树 ①IO次数更少 ②查询性能很稳定 ③范围查询更简便

- B+树的插入操作
①若为空树，那么创建一个节点并将记录插入其中，此时这个叶子结点也是根结点，插入操作结束。

此处的图片中例子的介数为5 。
a）空树中插入5。

②针对叶子类型结点：根据key值找到叶子结点，向这个叶子结点插入记录。插入后，若当前结点key的个数小于等于m-1（5-1 = 4），则插入结束。否则将这个叶子结点分裂成左右两个叶子结点，左叶子结点包含前m/2个（2个）记录，右结点包含剩下的记录，将第m/2+1个（3个）记录的key进位到父结点中（父结点一定是索引类型结点），进位到父结点的key左孩子指针向左结点，右孩子指针向右结点。将当前结点的指针指向父结点，然后执行第3步。

b）依次插入8，10，15。


c）插入16


插入16后超过了关键字的个数限制，所以要进行分裂。在叶子结点分裂时，分裂出来的左结点2个记录，右边3个记录，中间第三个数成为索引结点中的key（10），分裂后当前结点指向了父结点（根结点）。结果如下图所示。


③针对索引类型结点：若当前结点key的个数小于等于m-1（4），则插入结束。否则，将这个索引类型结点分裂成两个索引结点，左索引结点包含前(m-1)/2个key（2个），右结点包含m-(m-1)/2个key（3个），将第m/2个key进位到父结点中，进位到父结点的key左孩子指向左结点,，进位到父结点的key右孩子指向右结点。将当前结点的指针指向父结点，然后重复第3步。

d）插入17


e）插入18，插入后如下图所示


当前结点的关键字个数大于5，进行分裂。分裂成两个结点，左结点2个记录，右结点3个记录，关键字16进位到父结点（索引类型）中，将当前结点的指针指向父结点。


f）插入若干数据后



g）在上图中插入7，结果如下图所示


当前结点的关键字个数超过4，需要分裂。左结点2个记录，右结点3个记录。分裂后关键字7进入到父结点中，将当前结点的指针指向父结点，结果如下图所示。


当前结点的关键字个数超过4，需要继续分裂。左结点2个关键字，右结点2个关键字，关键字16进入到父结点中，将当前结点指向父结点，结果如下图所示。


当前结点的关键字个数满足条件，插入结束。

此处参考了：https://blog.csdn.net/Fmuma/article/details/80287924

B+树的删除操作
下面是一颗5阶B树的删除过程，5阶B数的结点最少2个key，最多4个key。

如果叶子结点中没有相应的key，则删除失败。否则执行下面的步骤。

①删除叶子结点中对应的key。删除后若结点的key的个数大于等于Math.ceil(m/2) – 1（>=2），删除操作结束，否则执行第2步。

a）初始状态


b）删除22,删除后结果如下图



删除后叶子结点中key的个数大于等于2，删除结束。
②若结点的key的个数小于Math.ceil(m/2) – 1（<2），且兄弟结点key有富余（大于Math.ceil(m/2)– 1）（>2），向兄弟结点借一个记录，同时用借到的key替换父结（指当前结点和兄弟结点共同的父结点）点中的key，删除结束。否则执行第3步。

c）删除15，删除后的结果如下图所示。



删除后当前结点只有一个key，不满足条件，而兄弟结点有三个key，可以从兄弟结点借一个关键字为9的记录,同时更新将父结点中的关键字由10也变为9，删除结束。

③若结点的key的个数小于Math.ceil(m/2) – 1（<2），且兄弟结点中没有富余的key（小于Math.ceil(m/2)– 1），则当前结点和兄弟结点合并成一个新的叶子结点，并删除父结点中的key，将当前结点指向父结点（必为索引结点），执行第4步（第4步以后的操作和B树就完全一样了，主要是为了更新索引结点）。

d）删除7，删除后的结果如下图所示



当前结点关键字个数小于2，（左）兄弟结点中的也没有富余的关键字（当前结点还有个右兄弟，不过选择任意一个进行分析就可以了，这里我们选择了左边的），所以当前结点和兄弟结点合并，并删除父结点中的key，当前结点指向父结点。

④若索引结点的key的个数大于等于Math.ceil(m/2) – 1（>=2），则删除操作结束。否则执行第5步。

⑤若兄弟结点有富余，父结点key下移，兄弟结点key上移，删除结束。否则执行第6步

⑥当前结点和兄弟结点及父结点下移key合并成一个新的结点。将当前结点指向父结点，重复第4步。

此时当前结点的关键字个数小于2，兄弟结点的关键字也没有富余，所以父结点中的关键字下移，和两个孩子结点合并，结果如下图所示。

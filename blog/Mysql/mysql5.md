# MYSQL核心技术总结


> Mysql **索引概述下**

- 最左前缀：name字段建立索引，"where name like ‘张 %’"。这时，你也能够用上这个索引，查找到第一个符合条件的记录，然后向后遍历，直到不满足条件为止。
> 可以看到，不只是索引的全部定义，只要满足**最左前缀**，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。
- 在建立联合索引的时候，如何安排索引内的字段顺序。
> 我们的评估标准是，**索引的复用能力**。因为可以支持最左前缀，所以当已经有了 (a,b) 这个联合索引后，一般就不需要单独在 a 上建立索引了。因此，第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。

  >**如果既有联合查询，又有基于 a、b 各自的查询呢？**查询条件里面只有 b 的语句，是无法使用 (a,b) 这个联合索引的，这时候你不得不维护另外一个索引，也就是说你需要同时维护 (a,b)、(b) 这两个索引。这时候，我们要考虑的原则就是**空间**了。比如上面这个市民表的情况，name 字段是比 age 字段大的 ，那我就建议你创建一个（name,age) 的联合索引和一个 (age) 的单字段索引。

- 索引下推
>我们还是以市民表的联合索引（name, age）为例。如果现在有一个需求：检索出表中“名字第一个字是张，而且年龄是 10 岁的所有男孩”。那么，SQL 语句是这么写的：
```
mysql> select * from tuser where name like '张%' and age=10 and ismale=1;
```
你已经知道了前缀索引规则，所以这个语句在搜索索引树的时候，只能用 “张”，找到第一个满足条件的记录 ID3。当然，这还不错，总比全表扫描要好。然后呢？当然是判断其他条件是否满足。在 MySQL 5.6 之前，只能从 ID3 开始一个个回表。到主键索引上找出数据行，再对比字段值。而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

- 索引的删除和重建
  >如果你要重建索引 k，你的两个 SQL 语句可以这么写：
  ```
    alter table T drop index k;
    alter table T add index(k);
  ```
  如果你要重建主键索引，也可以这么写：
  ```
  alter table T drop primary key;
  alter table T add primary key(id);
  ```
  为什么要重建索引。我们文章里面有提到，索引可能因为删除，或者页分裂等原因，导致数据页有空洞，**重建索引的过程会创建一个新的索引，把数据按顺序插入，这样页面的利用率最高，也就是索引更紧凑、更省空间**。
  重建索引 k 的做法是合理的，可以达到省空间的目的。但是，重建主键的过程不合理。**不论是删除主键还是创建主键，都会将整个表重建**。所以连着执行这两个语句的话，第一个语句就白做了。这两个语句，你可以用这个语句代替 ： alter table T engine=InnoDB。

- sql选择
  - 1.select * from T where k in(1,2,3,4,5)

  - 2.select * from T where k between 1 and 5

  > 第一个要树搜素5次  第二个搜索一次，第二个较好

    - like 'j' 或 'j%' 可以使用索引，并且快速定位记录。
    - like '%j' 或 '%j%'，只是在二级索引树上遍历查找记录，并不能快速定位（扫描了整棵索引树），使用了索引但不能加快速度。

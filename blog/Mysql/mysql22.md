# MYSQL核心技术总结


> Mysql  **临时表**

**union**
```
(select 1000 as f) union (select id from t1 order by id desc limit 2);
```

这个语句的执行流程是这样的：
1. 创建一个内存临时表，这个临时表只有一个整型字段 f，并且 f 是主键字段。

2. 执行第一个子查询，得到 1000 这个值，并存入临时表中。
3. 执行第二个子查询：拿到第一行 id=1000，试图插入临时表中。但由于 1000 这个值已经存在于临时表了，违反了唯一性约束，所以插入失败，然后继续执行；
4. 取到第二行 id=999，插入临时表成功。
5. 从临时表中按行取出数据，返回结果，并删除临时表，结果中包含两行数据分别是 1000 和 999。

>如果把上面这个语句中的 union 改成 union all 的话，就没有了“去重”的语义。这样执行的时候，就依次执行子查询，得到的结果直接作为结果集的一部分，发给客户端。因此也就不需要临时表了。

**group by 执行流程**

```
select id%10 as m, count(*) as c from t1 group by m;
```

这个语句的执行流程是这样的：
1. 创建内存临时表，表里有两个字段 m 和 c，主键是 m；

2. 扫描表 t1 的索引 a，依次取出叶子节点上的 id 值，计算 id%10 的结果，记为 x；如果临时表中没有主键为 x 的行，就插入一个记录 (x,1);如果表中有主键为 x 的行，就将 x 这一行的 c 值加 1；
3. 遍历完成后，再根据字段 m 做排序，得到结果集返回给客户端。

**优化**

不论是使用内存临时表还是磁盘临时表，group by 逻辑都需要构造一个带唯一索引的表，执行代价都是比较高的。如果表的数据量比较大，上面这个 group by 语句执行起来就会很慢，我们有什么优化的方法呢？要解决 group by 语句的优化问题，你可以先想一下这个问题：执行 group by 语句为什么需要临时表？group by 的语义逻辑，是统计不同的值出现的个数。但是，由于每一行的 id%100 的结果是无序的，所以我们就需要有一个临时表，来记录并统计结果。那么，如果扫描过程中可以保证出现的数据是有序的，是不是就简单了呢？

你可以用下面的方法创建一个列 z，然后在 z 列上创建一个索引（如果是 MySQL 5.6 及之前的版本，你也可以创建普通列和索引，来解决这个问题）。
```
alter table t1 add column z int generated always as(id % 100), add index(z);
```
这样，索引 z 上的数据就是类似图 10 这样有序的了。上面的 group by 语句就可以改成：
```
select z, count(*) as c from t1 group by z;
```
这个语句的执行不再需要临时表，也不需要排序了。

# hash碰撞冲突


如果两个输入串的hash函数的值一样，则称这两个串是一个碰撞(Collision)。既然是把任意长度的字符串变成固定长度的字符串，所以必有一个输出串对应无穷多个输入串，**碰撞是必然存在的**。

一个优良的hash函数 f 应当满足以下三个条件：

（1）对于任意y，寻找x，使得f(x)=y，在计算上是不可行的。

（2）给定x1∈A,找x2∈B，，使得f(x1)=f(x2)，在计算上是不可能的，这也就是弱无碰撞性。

（3）寻找x1，x2，使得f(x1)=f(x2)，在计算上也是不可行的，这也就是强无碰撞性。

这样就称为安全保密的Hash函数，除了枚举外不可能有别的更快的方法。如第3条，根据生日定理，要想找到这样的x1，x2，理论上需要大约2^(n/2)的枚举次数。

因为前两条都能被破坏的hash函数太弱而被抛弃，几乎所有的hash函数的破解，都是指的破坏上面的第3条性质，即找到一个碰撞。在密码学上还有一个概念是理论破解，指的是提出一个算法，使得可以用低于理论值得枚举次数找到碰撞。

解决hash冲突的常用方法：

##### 开放定址法
基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。

**有三种技术用于开放寻址法：线性探测、二次探测以及双重探测。**
- 线性探测

  给定一个普通的散列函数h'：U —>{0，1，.....，m-1}，线性探测方法采用的散列函数为：h(k,i) = (h'(k)+i)mod m，i=0,1,....,m-1　　
  探测时从i=0开始，首先探查T[h'(k)]，然后依次探测T[h'(k)+1]，…，直到T[h'(k)+m-1]，此后又循环到T[0]，T[1]，…，直到探测到T[h'(k)-1]为止。探测过程终止于三种情况：
  1. 若当前探测的单元为空，则表示查找失败（若是插入则将key写入其中）；

  2. 若当前探测的单元中含有key，则查找成功，但对于插入意味着失败；

  3. 若探测到T[h'(k)-1]时仍未发现空单元也未找到key，则无论是查找还是插入均意味着失败(此时表满)。

- 二次探测

  二次探测法的探查序列是：h(k,i) =(h'(k)+i*i)％m ,0≤i≤m-1 。初次的探测位置为T[h'(k)]，后序的探测位置在次基础上加一个偏移量，该偏移量以二次的方式依赖于i。该方法的缺陷是不易探查到整个散列空间。

- 双重散列

  该方法是开放寻址的最好方法之一，因为其产生的排列具有随机选择的排列的许多特性。采用的散列函数为：h(k,i)=(h1(k)+ih2(k)) mod m。其中h1和h2为辅助散列函数。初始探测位置为T[h1(k)]，后续的探测位置在此基础上加上偏移量h2(k)模m。

##### 再哈希法
这种方法是同时构造多个不同的哈希函数：
Hi=RH1（key）  i=1，2，…，k
当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。

##### 链地址法
这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。

##### 建立公共溢出区
这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。



**拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？**

之所以选择红黑树是为了解决二叉查找树的缺陷，**二叉查找树在特殊情况下会变成一条线性结构**（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢。**而红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，引入红黑树就是为了查找数据快，解决链表查询深度的问题**，我们知道红黑树属于平衡二叉树，但是为了保持“平衡”是需要付出代价的，但是该代价所损耗的资源要比遍历线性链表要少，所以当长度大于8的时候，会使用红黑树，链表长度低于6，就把红黑树转回链表，因为根本不需要引入红黑树，引入反而会慢。
